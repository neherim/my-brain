---
share: true
alias: aggregate
---

Агрегат (*aggregate*) — паттерн из [[Статьи/Domain Driven Design/Domain Driven Design|Domain Driven Design]]. Представляет собой дерево связанных сущностей - объектов предметной области. Доступ ко всем объектом осуществляется только через один главный объект - "корень агрегата".
Объекты снаружи должны ссылаться только на корень агрегата и никогда на остальные объекты, которые в него входят. Корень агрегата отвечает за поддержание консистентности всего агрегата.

Агрегаты хорошо подходят для программировании сложной бизнес логики, поддержания консистентности при конкурентном доступе к данным, для управления сложностью, повышения предсказуемости и тестируемости. Нет смысла использовать их в простых задачах, где это не требуется.

# Пример агрегата

``` java
class Order {
    private Integer id;
    private List<Item> items;
    private Integer sum;
    private DiscountPolicy discountPolicy;

    public void addItem(Item item) {
        items.add(item);
        var itemFinalPrice = discountPolicy.applyDiscount(item.getPrice());
        sum += itemFinalPrice;
    }

    public Integer getSum() {
        return sum;
    }
}
```

В данном примере класс Order - корень агрегата, все изменения в корзине заказа (items) и итоговой стоимости (sum) производятся только в нем. В классе нет setter'ов, через которые можно было бы нарушить его консистентность (например, добавив товар в корзину без пересчета суммы).
Вместо того, чтобы размазывать бизнес логику и проверки состояния по разным классам мы помещаем их в один класс, непосредственно рядом самими данными.

# Правила проектирования агрегатов

- Агрегат также можно рассматривать как границу транзакции в БД и минимальную единицу хранения. При запросе агрегата из БД он загружается целиком, также целиком сохраняется по завершению работы с ним. Поэтому для улучшения производительности агрегат должен быть как можно меньше.
- Агрегат может ссылаться на другой агрегат только по id. Не допускается модификация одного агрегата через вызов метода из корня другого агрегата.
- Обмениваться информацией агрегаты могут через доменные события, придерживаясь [[Статьи/Архитектура/Архитектура Систем/Eventual consistency|eventual consistency]].
- Необходимо стремиться к тому, чтобы в рамках одной транзакции менялся только один агрегат. Если появляется требование изменить несколько агрегатов в рамках одной транзакции, то стоит задуматься. Возможно границы агрегатов были выбраны неверно, или в доменной области существует еще не открытая разработчиком новая концепция, новый агрегат. Нарушая это правило мы теряем возможность хранить агрегаты в разных БД. Как следствие, не сможем, в случае необходимости, разнести по разным сервисам.
- Разработчик должен контролировать одновременный доступ к агрегату из разных потоков и сервисов. Например, через [[Статьи/Базы данных/Оптимистичная блокировка|оптимистичную]] или [[Статьи/Базы данных/Пессимистичная блокировка|пессимистичную]] блокировку на уроне БД.

# Чем полезен паттерн агрегат?

Используя паттерн агрегат и придерживаясь приведенных выше ограничений мы получаем следующие свойства:
- Эффективная работа с NoSQL БД. Так как агрегат уже является границей транзакции, то мы можем загружать и сохранять его целиком в БД, что хорошо ложиться на концепцию NoSQL БД.
- Потенциал к масштабированию хранения данных агрегата. За счет того, что агрегат является атомарной единицей бизнес логики и данных, и ссылается на остальные агрегат только по уникальному в ID - это позволяет переносить данные агрегата из одной БД в другую, использовать шардирование и партиционирование, не боясь нарушить консистентность.
- High [[Статьи/Архитектура/Архитектура Приложений/Cohesion|cohesion]]. Бизнес правила и операции, которые относятся к одной сущности хранятся в одном месте, а не по всему коду в *Service* классах.
- Low [[Статьи/Архитектура/Архитектура Приложений/Coupling|coupling]]. Благодаря правилу "ссылаться на другой агрегат только по Id" - агрегаты слабо связаны друг другом.

# Как определить, что граница агрегата выбрана правильно?
- Есть ли аналог в реальном мире?
- Агрегат не пересекает [[Статьи/Domain Driven Design/Bounded Context|Bounded Context]]?
- Есть ли инвариант для этой группы объектов?
- Данные должны изменяться в рамках одной транзакции?

# Статьи
- [Effective Aggregate Design Part I: Modeling a Single Aggregate](https://www.dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_1.pdf)
- [Effective Aggregate Design Part II: Making Aggregates Work Together](https://www.dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_2.pdf)
- [Effective Aggregate Design Part III: Gaining Insight Through Discovery](https://www.dddcommunity.org/wp-content/uploads/files/pdf_articles/Vernon_2011_3.pdf)
