---
share: true
---
Оверинжениринг - это попытка решить проблему, которой нет. Это когда к отвертке прикручивается вилка, на случай если захочется перекусить во время сборки мебели.

>[!quote]
>Simplicity is prerequisite for reliability 
>\-- Dijkstra

Очень часто встречающаяся проблема.
Например, в задаче сказано - необходимо сохранить файл на диск. Вы для решения этой задачи разрабатываете универсальную систему по записи чего угодно куда угодно из десятка абстрактных классов, и нескольких фабрик.
Или, требуется написать простой веб сервис на 5 пользователей, а вы тащите реактивные библиотеки рассчитанные на 10к одновременных подключений.

Не нужно обманываться, в этих примерах программисты не думают о будущем или строят расширяемую систему - они занимаются оверинженирингом.

Возможно, когда-то в будущем и появятся новые требования или пользователей станет сильно больше, а может быть и нет. Но вот излишне усложненный код, с которым придется работать коллегам в ближайшие N лет написали уже сейчас.
Затраты на чтение и поддержку этого кода будут значительными, а плюсов от его расширяемости - может никто и не увидеть.

Истинная же мотивация оверинжениринга, чаще всего, просто желание развлечь себя за счет работодателя или показать коллегам свою крутость.

Часто встречаю две крайности - либо весь код одной портянкой, либо дымящаяся куча паттернов, абстракций и обобщенного программирования. И надо сказать, что первый вариант намного лучше второго.
Часто программист убеждает себя, что вот в этом месте уж точно нужна расширяемость, но на самом деле он просто хочет написать что-то «веселое».

Это нормальный этап взросления инженера. Чаще всего с опытом это проходит, особенно когда приходится разбираться в коде коллег, с похожими проблемами. Самый лучший код - скучный.
Именно умение писать простой, скучный, код и есть высшая точка профессионализма для программиста.
Но нужно понимать, что просто не значит легко, писать простой код чертовски сложно (simple is not easy).

Код с функциями на 500 строк - лучше, чем лапша из абстрактных классов. Синхронный код лучше асинхронного. Монолит лучше микросервисов.

# Ссылки
1. [Anemic Domain Model](https://martinfowler.com/bliki/AnemicDomainModel.html)
2. [Cohesion and Coupling: the difference · Enterprise Craftsmanship](https://enterprisecraftsmanship.com/posts/cohesion-coupling-difference/)
3. [Making Impossible States Impossible by Richard Feldman - YouTube](https://www.youtube.com/watch?v=IcgmSRJHu_8&ab_channel=elm-conf)
4. [Simple Made Easy - Rich Hickey (2011) - YouTube](https://www.youtube.com/watch?v=LKtk3HCgTa8&ab_channel=ClojureTV)
6. [Why extends is evil](https://www.infoworld.com/article/2073649/why-extends-is-evil.html)
