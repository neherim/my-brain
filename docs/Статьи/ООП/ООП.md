---
share: true
---

ООП хорошо подходит для сложной бизнес логики, для интеграционного кода он не очень подходит

## Fragile base class problem
Проблема хрупкого базового класса заключается в том, что малейшие правки в деталях реализации базового класса могут привнести ошибку в производные классы. В худшем случае это приводит к тому, что любая успешная модификация базового класса требует предварительного изучения всего дерева наследования, и зачастую невозможна (без создания ошибок) даже в этом случае.
В общем случае проблема не решаема, и является одним из существенных недостатков наследования в ООП.

Рассмотрим пример "хрупкого" базового класса. Мы хотим разработать коллекцию Set, которая бы могла быстро ответить, сколько элементов в нее добавлено. Предположим, что мы наследовались от HashSet и переопределили методы добавления элементов в коллекцию.

```java
public class CountingSet<E> extends HashSet<E> {
    private int count;

    @Override
    public boolean add(E e) {
        count++;
        return super.add(e);
    }

    @Override
    public boolean addAll(Collection<? extends E> c) {
        count += c.size();
        return super.addAll(c);
    }

    @Override
    public int size() {
        return count;
    }
}
```

Что по вашему мнению выведет данный код:
```java
   var set = new CountingSet<Integer>();
   set.addAll(List.of(42, 0, 12));
   System.out.println("Set size: " + set.size());
```

Правильный ответ: зависит от имплементации `addAll` у базового класса. Например, в данном случае вызовется метод `AbstractCollection.addAll`, который реализован через вызов метода `add(E e)` в цикле, но при этом будет вызываться наш, переопределенный метод `add` и соответственно счетчик будет увеличиваться два раза. Размер коллекции будет равен 6.
Допустим, мы подстроимся под имплементацию и уберем наращивание счетчика из `addAll`. Теперь наш код работает правильно, но ровно до того момента, пока какой-нибудь класс в цепочке наследников между нашим `CountingSet<E>` и интерфейсом `Collection<E>` не задумается об оптимизации и не переопределит `addAll` убрав из него добавление элементов по одному через метод `add`. И наш класс снова работает неправильно.